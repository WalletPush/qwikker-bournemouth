import { NextRequest, NextResponse } from 'next/server'
import { generateHybridAIResponse } from '@/lib/ai/hybrid-chat'
import { generateQuickReplies, categorizeUserMessage } from '@/lib/ai/chat'
import { getFranchiseCityFromRequest } from '@/lib/utils/franchise-areas'
import { getValidatedUser } from '@/lib/utils/wallet-pass-security'
import { createTenantAwareServerClient } from '@/lib/utils/tenant-security'
import { getOpenStatusForToday } from '@/lib/utils/opening-hours'

type MentionedBiz = { name: string; slug: string }

function extractMentionedBusinessesFromText(text: string): MentionedBiz[] {
  const matches = [...text.matchAll(/\*\*\[([^\]]+)\]\(\/user\/business\/([a-z0-9-]+)\)\*\*/g)]
  return matches.map(m => ({ name: m[1], slug: m[2] }))
}

/**
 * Infer which business the user is asking about from recent assistant messages
 * Uses markdown links generated by the AI to match business names/tokens to slugs
 */
function inferSelectedBusinessSlugFromHistory(
  message: string,
  conversationHistory: Array<{ role: string; content: string }>
): string | null {
  const msg = (message || '').toLowerCase()

  // Look back over the last few assistant messages for linked businesses
  const recent = [...(conversationHistory || [])]
    .reverse()
    .filter(m => m?.role === 'assistant' && typeof m?.content === 'string')
    .slice(0, 6)

  const mentioned: MentionedBiz[] = []
  for (const m of recent) {
    mentioned.push(...extractMentionedBusinessesFromText(m.content))
    // stop early if we found any in the most recent assistant message
    if (mentioned.length > 0) break
  }

  if (mentioned.length === 0) return null

  // If user message includes a mentioned business name (or a strong token), choose that slug
  // Deterministic: exact substring match on the name (lowercased)
  for (const { name, slug } of mentioned) {
    const n = name.toLowerCase()
    if (n.length >= 4 && msg.includes(n)) return slug
  }

  // Token fallback: if user says "triangle" and we have "Triangle GYROSS"
  // Deterministic: match any word token >= 6 chars from business name that appears in message
  for (const { name, slug } of mentioned) {
    const tokens = name
      .toLowerCase()
      .split(/[^a-z0-9]+/g)
      .filter(t => t.length >= 6)
    if (tokens.some(t => msg.includes(t))) return slug
  }

  // If exactly one unique slug was mentioned recently, assume that's the selected business
  const unique = Array.from(new Set(mentioned.map(m => m.slug)))
  if (unique.length === 1) return unique[0]

  return null
}

/**
 * Generate slug from business name (matches DB slug generation logic)
 */
function generateSlugFromName(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')
}

/**
 * Helper: Force each business link to start a new paragraph
 * MECHANICAL FIX: Handles both linked and unlinked bold business names
 */
function forceNewParagraphPerBusinessLink(text: string): string {
  if (!text) return text

  // Match BOTH formats:
  // 1. Full link: **[Business Name](/user/business/slug)**
  // 2. Plain bold: **Business Name** (when model forgets links)
  const linkRe = /\*\*\[([^\]]+)\]\(\/user\/business\/[a-z0-9-]+\)\*\*/g
  const boldRe = /\*\*([A-Z][^*]{2,}?(?:'s)?[^*]*?)\*\*/g
  
  // First collect all business mentions (linked or not)
  const mentions: Array<{ text: string; index: number }> = []
  
  // Find all linked businesses
  let m: RegExpExecArray | null
  const linkedText = text
  while ((m = linkRe.exec(linkedText)) !== null) {
    mentions.push({ text: m[0], index: m.index })
  }
  
  // Find all bold text that looks like business names (Title Case, reasonable length)
  // But ONLY if we have < 2 linked mentions (fallback mode)
  if (mentions.length < 2) {
    const boldMatches = text.match(boldRe) || []
    // Filter to likely business names: starts with capital, has reasonable words
    const likelyBusinessNames = boldMatches.filter(m => {
      const inner = m.replace(/\*\*/g, '')
      // Business names typically: Title Case, 2-50 chars, not generic phrases
      return inner.length >= 5 && 
             inner.length <= 60 &&
             !/^(The|A|An|Good|Great|Best|Perfect|Love|Want|Curious|Check|Try|Visit)\b/.test(inner)
    })
    
    if (likelyBusinessNames.length >= 2) {
      // Re-scan to get positions
      likelyBusinessNames.forEach(pattern => {
        const idx = text.indexOf(pattern)
        if (idx >= 0 && !mentions.some(m => m.index === idx)) {
          mentions.push({ text: pattern, index: idx })
        }
      })
    }
  }
  
  if (mentions.length < 2) return text.trimEnd()
  
  // Sort by index (earliest first)
  mentions.sort((a, b) => a.index - b.index)
  
  // Insert \n\n before each mention except the first
  let result = text
  let offset = 0
  
  for (let i = 1; i < mentions.length; i++) {
    const mention = mentions[i]
    const insertPos = mention.index + offset
    
    // Check if already has proper spacing
    const before = result.substring(Math.max(0, insertPos - 2), insertPos)
    if (before !== '\n\n') {
      result = result.substring(0, insertPos) + '\n\n' + result.substring(insertPos)
      offset += 2
    }
  }
  
  return result
    .replace(/\n{3,}/g, '\n\n')
    .trimEnd()
}

/**
 * Detect "near me" intent from user message
 */
function detectNearMeIntent(message: string): boolean {
  const lowerMessage = message.toLowerCase()
  const nearMePatterns = [
    'near me',
    'close by',
    'nearby',
    'around here',
    'walking distance',
    'close to me',
    'around me',
    'in my area',
    'local to me',
    'closest',
    'nearest'
  ]
  return nearMePatterns.some(pattern => lowerMessage.includes(pattern))
}

/**
 * Detect primary intent from user message
 */
function classifyMessageType(message: string): 'near_me' | 'browse' | 'events' | 'offers' | 'unknown' {
  const lowerMessage = message.toLowerCase()
  
  if (detectNearMeIntent(message)) return 'near_me'
  if (lowerMessage.includes('event') || lowerMessage.includes('happening')) return 'events'
  if (lowerMessage.includes('offer') || lowerMessage.includes('deal') || lowerMessage.includes('discount')) return 'offers'
  if (lowerMessage.includes('find') || lowerMessage.includes('show') || lowerMessage.includes('restaurant') || lowerMessage.includes('bar') || lowerMessage.includes('cafe')) return 'browse'
  
  return 'unknown'
}

/**
 * Generate deterministic quick replies based on context
 */
function generateDeterministicQuickReplies(
  intent: string,
  needsLocation: boolean,
  hasBusinessResults: boolean,
  hasEventCards: boolean
): string[] {
  if (needsLocation) {
    return ["Use my location", "Show city centre instead"]
  }
  
  if (hasBusinessResults) {
    return ["Show me on Atlas", "More like this", "Filter options"]
  }
  
  if (hasEventCards) {
    return ["More events", "This weekend", "Family-friendly"]
  }
  
  // Default suggestions
  if (intent === 'offers') {
    return ["Current deals", "Qwikker Picks", "Near me"]
  }
  
  return ["Find restaurants", "Current deals", "Qwikker Picks"]
}

export async function POST(request: NextRequest) {
  try {
    const { message, walletPassId, conversationHistory, userLocation } = await request.json()

    // Validate required fields
    if (!message || typeof message !== 'string') {
      return NextResponse.json(
        { error: 'Message is required and must be a string' },
        { status: 400 }
      )
    }

    // Get franchise city from request
    const city = await getFranchiseCityFromRequest()
    console.log(`ü§ñ AI Chat request for city: ${city}`)

    // Validate user if wallet pass ID provided
    let userName = 'there'
    if (walletPassId) {
      const { user, isValid } = await getValidatedUser(walletPassId)
      if (isValid && user) {
        userName = user.name || 'there'
        console.log(`‚úÖ Validated user: ${userName}`)
      } else {
        console.warn(`‚ö†Ô∏è Invalid wallet pass ID in AI chat: ${walletPassId}`)
      }
    }
    
    // Detect intent
    const intent = classifyMessageType(message)
    const isNearMeQuery = intent === 'near_me'
    const hasUserLocation = !!(userLocation?.lat && userLocation?.lng)
    
    console.log(`üéØ Intent: ${intent}, NearMe: ${isNearMeQuery}, HasLocation: ${hasUserLocation}`)
    
    // Near-me queries without location: still return results, but flag that location would help
    const needsLocation = isNearMeQuery && !hasUserLocation
    
    if (needsLocation) {
      console.log('üìç Near-me query without location ‚Äî will return results sorted by rating, flag for location')
    }

    // üöÄ Generate AI response using HYBRID system (GPT-4o-mini + GPT-4o)
    const result = await generateHybridAIResponse(message, {
      city,
      userName,
      walletPassId,
      userLocation: hasUserLocation ? {
        latitude: userLocation.lat,
        longitude: userLocation.lng
      } : undefined
    }, conversationHistory || [])

    if (!result.success) {
      console.error('‚ùå AI response generation failed:', result.error)
      
      // If the error is about missing API key or empty knowledge base, show growth message
      const isConfigurationError = result.error?.includes('not configured') || result.error?.includes('knowledge base')
      
      // Get city display name for personalized message
      const cityDisplayName = city.charAt(0).toUpperCase() + city.slice(1)
      
      return NextResponse.json({
        response: isConfigurationError 
          ? `I'm still getting to know ${cityDisplayName}. As local businesses verify details, I'll be able to recommend specific dishes, offers and hidden spots. For now, explore what's already live in the Discover section and your pass will update automatically.`
          : `I'm still getting to know ${cityDisplayName}. As local businesses verify details, I'll be able to recommend specific dishes, offers and hidden spots. For now, explore what's already live in the Discover section and your pass will update automatically.`,
        intent: 'unknown',
        needsLocation: false,
        showAtlasCta: false,
        sources: [],
        quickReplies: [] // REMOVED: Let users type what they want
      })
    }
    
    // üó∫Ô∏è ATLAS CTA LOGIC: Check ACTUAL shown results, not all candidates
    // Only show Atlas CTA if the businesses/pins we're ACTUALLY showing have 2+ valid coords
    const atlasAvailable = result.metadata?.atlasAvailable ?? false
    const coordsCandidateCount = result.metadata?.coordsCandidateCount ?? 0
    
    // Count how many businesses in carousel have valid coords
    const hasAtlasCarousel = (result.businessCarousel || []).filter((b: any) => 
      b.latitude && 
      b.longitude && 
      Math.abs(Number(b.latitude)) <= 90 && 
      Math.abs(Number(b.longitude)) <= 180
    ).length >= 2
    
    // Count how many map pins have valid coords
    const hasAtlasPins = (result.mapPins || []).filter((p: any) => 
      p.latitude && 
      p.longitude && 
      Math.abs(Number(p.latitude)) <= 90 && 
      Math.abs(Number(p.longitude)) <= 180
    ).length >= 2
    
    const hasActualBusinessResults = !!(
      (result.businessCarousel && result.businessCarousel.length > 0) ||
      (result.mapPins && result.mapPins.length > 0)
    )
    
    if (process.env.NODE_ENV === 'development') {
      console.log('üó∫Ô∏è ATLAS CTA CHECK:')
      console.log(`   atlasAvailable (from hybrid-chat): ${atlasAvailable}`)
      console.log(`   coordsCandidateCount: ${coordsCandidateCount}`)
      console.log(`   hasActualBusinessResults: ${hasActualBusinessResults}`)
      console.log(`   hasAtlasCarousel (2+ with coords): ${hasAtlasCarousel}`)
      console.log(`   hasAtlasPins (2+ with coords): ${hasAtlasPins}`)
    }
    
    // Show Atlas CTA only if the ACTUAL shown results have 2+ valid coords
    const showAtlasCta = atlasAvailable && hasActualBusinessResults && (hasAtlasCarousel || hasAtlasPins)
    
    // üîß POST-PROCESS: Remove Atlas mentions from AI response if model mentioned it but UI won't show CTA
    // CRITICAL: Use showAtlasCta (final UI truth), not atlasAvailable (prompt hint)
    let finalResponse = result.response || ''
    
    // üéØ DETAIL MODE: Check if this is a detail request about a specific business
    // GUARD: If user is asking for menu items/cocktails/dishes, do NOT enter detail mode
    // Let hybrid AI + KB do extraction (cocktails, dishes, prices, etc)
    const hasSpecificMenuQuery = /\b(cocktail|cocktails|drink|drinks|beer|wine|spirits|menu|food|dishes?|what do they (sell|serve|have|offer)|what('?s| is) on (the )?menu|recommend|best (dish|dishes)|signature|specialt(y|ies))\b/i.test(message)
    
    // STRICT: Only trigger on explicit detail requests, NOT general discovery or menu queries
    const isDetailQuery = 
      (!hasSpecificMenuQuery && /^(tell me more|tell me about|more about|details about|what about|more on)\b/i.test(message)) || // Starts with explicit detail phrase (but NOT menu query)
      (/\b(hours?|opening|open now|what time|closing|close time|phone|call|contact|address|where is|directions|how do i get|website|book|booking)\b/i.test(message) && message.split(/\s+/).length <= 15) // Practical query

    // üéØ CRITICAL FIX: Resolve business from CURRENT message FIRST, scoped to recent candidates
    function resolveBusinessFromCurrentMessage(
      msg: string, 
      recentCandidates: Array<{name: string; slug: string}>
    ): { slug: string | null; matchedBy: string; ambiguous?: boolean } {
      
      if (recentCandidates.length === 0) {
        return { slug: null, matchedBy: 'no_candidates' }
      }
      
      // Normalize for matching
      const normalize = (s: string) => 
        s.toLowerCase()
          .replace(/['']/g, '')
          .replace(/[^\w\s]/g, ' ')
          .replace(/\s+/g, ' ')
          .trim()
      
      const normalized = normalize(msg)
      
      // Extract potential business name tokens (remove common query words)
      const stopWords = [
        'what', 'is', 'are', 'the', 'a', 'an', 'open', 'hours', 'time', 'does', 'do', 
        'when', 'where', 'how', 'can', 'i', 'get', 'to', 'about', 'tell', 'me', 'more', 
        'info', 'information', 'it', 'they', 'close', 'closing', 'opening', 'you', 'your'
      ]
      
      // Banned tokens that are too generic (common in many business names)
      const genericTokens = [
        'restaurant', 'bistro', 'bar', 'grill', 'cafe', 'coffee', 'kitchen', 
        'pub', 'lounge', 'house', 'place', 'spot', 'food'
      ]
      
      const tokens = normalized
        .split(/\s+/)
        .filter(t => t.length >= 3 && !stopWords.includes(t) && !genericTokens.includes(t))
      
      if (tokens.length === 0) {
        return { slug: null, matchedBy: 'no_tokens' }
      }
      
      // Match tokens against recent candidates
      const matches: Array<{biz: {name: string; slug: string}; score: number; matchedTokens: string[]}> = []
      
      for (const biz of recentCandidates) {
        const bizNormalized = normalize(biz.name)
        const bizTokens = bizNormalized.split(/\s+/).filter(t => t.length >= 3)
        
        // Find matching tokens
        const matchingTokens = tokens.filter(t => bizTokens.includes(t))
        
        if (matchingTokens.length >= 2) {
          // Strong match: 2+ tokens
          matches.push({ biz, score: matchingTokens.length * 10, matchedTokens: matchingTokens })
        } else if (matchingTokens.length === 1 && matchingTokens[0].length >= 6) {
          // Medium match: 1 strong token (6+ chars)
          matches.push({ biz, score: 5, matchedTokens: matchingTokens })
        }
      }
      
      if (matches.length === 0) {
        return { slug: null, matchedBy: 'no_match' }
      }
      
      if (matches.length > 1) {
        // Check if there's a clear winner (significantly higher score)
        matches.sort((a, b) => b.score - a.score)
        const topScore = matches[0].score
        const tiedMatches = matches.filter(m => m.score === topScore)
        
        if (tiedMatches.length > 1) {
          // Ambiguous - multiple businesses match equally
          console.log(`‚ö†Ô∏è [AMBIGUOUS MATCH] Multiple businesses match: ${tiedMatches.map(m => m.biz.name).join(', ')}`)
          return { slug: null, matchedBy: 'ambiguous', ambiguous: true }
        }
      }
      
      // Clear winner
      const winner = matches[0]
      console.log(`üéØ [CURRENT MESSAGE MATCH] Found "${winner.biz.name}" via tokens: ${winner.matchedTokens.join(', ')} (score: ${winner.score})`)
      return { slug: winner.biz.slug, matchedBy: 'current_message_token' }
    }

    // Extract recent business candidates from last 2-3 assistant messages
    function extractRecentBusinessCandidates(): Array<{name: string; slug: string}> {
      const recentAssistant = [...(conversationHistory || [])]
        .reverse()
        .filter(m => m?.role === 'assistant')
        .slice(0, 3) // Last 3 assistant messages only
      
      const candidates: Array<{name: string; slug: string}> = []
      const seen = new Set<string>()
      
      for (const m of recentAssistant) {
        const matches = [...(m.content || '').matchAll(/\*\*\[([^\]]+)\]\(\/user\/business\/([a-z0-9-]+)\)\*\*/g)]
        for (const match of matches) {
          const slug = match[2]
          if (!seen.has(slug)) {
            candidates.push({ name: match[1], slug })
            seen.add(slug)
          }
        }
      }
      
      return candidates
    }

    const metaBusinessId = result?.metadata?.currentBusinessId ?? null

    // ‚úÖ Build candidate list from recent conversation
    const recentCandidates = extractRecentBusinessCandidates()
    
    if (process.env.NODE_ENV !== 'production' && recentCandidates.length > 0) {
      console.log(`üìã [RECENT CANDIDATES] ${recentCandidates.length} businesses: ${recentCandidates.map(c => c.name).join(', ')}`)
    }

    // ‚úÖ PRIORITY 1: Try to resolve from CURRENT message (scoped to recent candidates)
    // ‚úÖ PRIORITY 2: Fall back to history only if current message has no business mention
    let resolvedSlug: string | null = null
    let matchedBy = 'none'
    
    if (isDetailQuery) {
      // Try current message first (scoped to recent candidates)
      const currentMatch = resolveBusinessFromCurrentMessage(message, recentCandidates)
      
      if (currentMatch.ambiguous) {
        // Multiple businesses match - don't guess, let AI ask for clarification
        console.log(`‚ö†Ô∏è [RESOLVER] Ambiguous match - will not auto-select business`)
        matchedBy = 'ambiguous'
      } else if (currentMatch.slug) {
        resolvedSlug = currentMatch.slug
        matchedBy = currentMatch.matchedBy
      } else {
        // Fall back to history only if no match in current message
        resolvedSlug = inferSelectedBusinessSlugFromHistory(message, conversationHistory || [])
        matchedBy = resolvedSlug ? 'history_fallback' : 'none'
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      console.log('üìã [DETAIL MODE CHECK]', {
        isDetailQuery,
        currentMessage: message,
        messageLength: message.split(/\s+/).length,
        resolvedSlug,
        matchedBy,
        candidateCount: recentCandidates.length
      })
    }

    const currentBusinessId = metaBusinessId
    const currentBusinessSlug = resolvedSlug

    const isDetailMode = !!(isDetailQuery && (currentBusinessId || currentBusinessSlug))

    if (process.env.NODE_ENV !== 'production') {
      console.log('üìã [DETAIL MODE RESULT]', {
        isDetailMode,
        metaBusinessId,
        currentBusinessSlug,
        matchedBy,
        willFetch: isDetailMode && (currentBusinessId || currentBusinessSlug)
      })
    }
    
    if (isDetailMode && (currentBusinessId || currentBusinessSlug)) {
      console.log(`üìã [DETAIL MODE] Fetching full business details`)
      
      try {
        const supabase = await createTenantAwareServerClient(city)
        
        // Fetch business with specific fields (matching actual DB columns)
        const selectFields = `
          id,
          business_name,
          display_category,
          rating,
          review_count,
          business_address,
          business_town,
          business_postcode,
          phone,
          website_url,
          business_description,
          business_hours_structured,
          latitude,
          longitude
        `
        
        let biz = null
        let matchedBy = 'none'

        // 1Ô∏è‚É£ Try ID (best)
        if (currentBusinessId) {
          const { data } = await supabase
            .from('business_profiles')
            .select(selectFields)
            .eq('id', currentBusinessId)
            .maybeSingle()

          if (data) {
            biz = data
            matchedBy = 'id'
          }
        }

        // 2Ô∏è‚É£ Fallback: resolve from inferredSlug -> business_name ilike, scoped to city
        if (!biz && currentBusinessSlug) {
          const words = currentBusinessSlug.split('-').filter(Boolean)
          const pattern = `%${words.join('%')}%` // e.g. "%triangle%gyross%"
          
          const { data } = await supabase
            .from('business_profiles')
            .select(selectFields)
            .eq('city', city)
            .ilike('business_name', pattern)
            .order('review_count', { ascending: false }) // deterministic tie-break
            .limit(1)
            .maybeSingle()

          if (data) {
            biz = data
            matchedBy = 'name_from_slug'
          }
        }

        if (process.env.NODE_ENV !== 'production') {
          console.log('üìã [DETAIL MODE] selected', {
            currentBusinessId,
            currentBusinessSlug,
            found: !!biz,
            matchedBy
          })
        }
        
        if (biz) {
          console.log(`‚úÖ [DETAIL MODE] Found business: ${biz.business_name}`)
          
          // Address deduplication helpers
          function normalizeAddress(str: string) {
            return str
              .replace(/\s+/g, ' ')
              .replace(/\s*,\s*/g, ', ')
              .replace(/,+/g, ',')
              .replace(/,\s*$/g, '')
              .trim()
          }
          
          function dedupeAddressParts(full: string, parts: string[]) {
            let out = full
            for (const part of parts.filter(Boolean)) {
              const p = part.trim()
              if (!p) continue
              // if full already includes part (case-insensitive), skip
              const re = new RegExp(p.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i')
              if (re.test(out)) continue
              out = normalizeAddress(`${out}, ${p}`)
            }
            return normalizeAddress(out)
          }
          
          function formatBusinessAddress(b: any) {
            const base = normalizeAddress(b.business_address || '')
            const town = normalizeAddress(b.business_town || '')
            const postcode = normalizeAddress(b.business_postcode || '')
            
            if (!base) {
              // build from parts if base is missing
              return normalizeAddress([town, postcode].filter(Boolean).join(', '))
            }
            
            // If base already includes postcode/town, don't append them
            return dedupeAddressParts(base, [town, postcode])
          }
          
          // Detect specific info requests (hours only, phone only, etc.)
          const asksHoursOnly = /\b(hours?|opening|open|close|closing|what time)\b/i.test(message) && 
                                !/\b(tell me|more about|details|info|everything|all about)\b/i.test(message)
          const asksPhoneOnly = /\b(phone|number|call|contact number)\b/i.test(message) && 
                                !/\b(tell me|more about|details|everything)\b/i.test(message)
          const asksAddressOnly = /\b(address|where is|location|directions)\b/i.test(message) && 
                                  !/\b(tell me|more about|details|everything)\b/i.test(message)
          
          // Build deterministic facts block (NO EMOJIS, clean labels)
          const facts: string[] = []
          const slug = generateSlugFromName(biz.business_name)
          
          // If asking for specific info only, don't repeat entire profile
          const isSpecificQuery = asksHoursOnly || asksPhoneOnly || asksAddressOnly
          
          if (!isSpecificQuery) {
            // Full profile header
            facts.push(`**[${biz.business_name}](/user/business/${slug})**`)
            facts.push('') // blank line
            
            // Business description (owner's voice) ‚Äî trim & cap at 800 chars
            const desc = biz.business_description?.trim()
            if (desc && desc.length > 0) {
              facts.push(desc.slice(0, 800))
              facts.push('') // blank line after description
            }
            
            // Rating (only if has reviews) - NO EMOJI
            if (biz.rating && biz.review_count > 0) {
              facts.push(`**Rating:** ${biz.rating}‚òÖ (${biz.review_count} reviews)`)
            }
            
            // Category - NO EMOJI
            if (biz.display_category) {
              facts.push(`**Category:** ${biz.display_category}`)
            }
          } else {
            // Just business name for specific queries
            facts.push(`**${biz.business_name}**`)
            facts.push('') // blank line
          }
          
          // Opening hours - NO EMOJI (always show if available, or if specifically asked)
          const wantsFullHours = /\b(full hours|all hours|weekly hours|hours for the week|hours during the week|week hours|hours this week|opening hours for the week|weekly schedule|complete hours|entire schedule)\b/i.test(message)
          
          if ((biz.business_hours_structured && asksHoursOnly) || wantsFullHours) {
            if (wantsFullHours) {
              // Format full weekly schedule
              function formatWeeklyHours(rawData: any): string {
                const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
                const dayLabels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
                
                const lines: string[] = []
                for (let i = 0; i < days.length; i++) {
                  const dayData = rawData[days[i]]
                  if (!dayData) continue
                  
                  if (dayData.closed === true) {
                    lines.push(`${dayLabels[i]}: Closed`)
                  } else if (dayData.open && dayData.close) {
                    // Parse and format times
                    const parseTime = (t: string) => {
                      const [h, m] = t.split(':').map(Number)
                      const ampm = h >= 12 ? 'pm' : 'am'
                      const hour12 = h % 12 === 0 ? 12 : h % 12
                      return m === 0 ? `${hour12}${ampm}` : `${hour12}:${String(m).padStart(2, '0')}${ampm}`
                    }
                    lines.push(`${dayLabels[i]}: ${parseTime(dayData.open)} ‚Äì ${parseTime(dayData.close)}`)
                  }
                }
                
                return lines.length > 0 ? lines.join('\n') : 'Hours not available'
              }
              
              const weeklySchedule = formatWeeklyHours(biz.business_hours_structured)
              // Format as bullet list to ensure proper line breaks in markdown
              const weeklyBullets = weeklySchedule.split('\n').map(l => `- ${l}`).join('\n')
              facts.push(`**Hours:**\n${weeklyBullets}`)
              console.log('üïí [FULL HOURS] Showing weekly schedule')
            } else {
              // Show today's status + summary
              const openStatus = getOpenStatusForToday(biz.business_hours_structured, new Date())
              console.log('üïí [DETAIL MODE HOURS]', { 
                hasHours: openStatus.hasHours, 
                todaySummary: openStatus.todaySummary, 
                conversational: openStatus.conversational,
                rawData: biz.business_hours_structured
              })
              if (openStatus.hasHours && openStatus.conversational && openStatus.todaySummary) {
                facts.push(`**Hours:** ${openStatus.conversational} (${openStatus.todaySummary})`)
              }
            }
          } else if ((asksHoursOnly || wantsFullHours) && !biz.business_hours_structured) {
            // User asked for hours but we don't have them
            facts.push(`**Hours:** I don't have the full hours for ${biz.business_name} yet.`)
            if (biz.phone) facts.push(`Try calling ${biz.phone} or check their website.`)
          }
          
          // Only show other details if NOT a hours-only query
          if (!asksHoursOnly || !isSpecificQuery) {
            // Address - NO EMOJI, deduplicated (show if not hours-only OR if address-only)
            if (asksAddressOnly || !isSpecificQuery) {
              const address = formatBusinessAddress(biz)
              if (address) {
                facts.push(`**Address:** ${address}`)
              }
            }
            
            // Phone - NO EMOJI (show if phone-only OR full details)
            if ((asksPhoneOnly || !isSpecificQuery) && biz.phone) {
              facts.push(`**Phone:** ${biz.phone}`)
            }
            
            // Website - NO EMOJI (only in full details)
            if (!isSpecificQuery && biz.website_url) {
              facts.push(`**Website:** ${biz.website_url}`)
            }
            
            // Directions link (only if user asks AND coordinates exist) - NO EMOJI
            const asksDirections = /\b(directions?|how do i get|where is|map)\b/i.test(message)
            if (asksDirections && biz.latitude && biz.longitude) {
              const lat = biz.latitude
              const lng = biz.longitude
              facts.push(`**Directions:** [Get Directions](https://www.google.com/maps/search/?api=1&query=${lat},${lng})`)
            }
          }
          
          const detailFactsBlock = facts.join('\n')
          
          // üö® DETAIL MODE: SHORT-CIRCUIT - Return immediately, bypass browse/carousel/pins
          console.log(`‚úÖ [DETAIL MODE] Built facts block (${detailFactsBlock.length} chars) - RETURNING EARLY`)
          
          // Only show Atlas CTA if THIS business has coords
          const hasCoords = !!(biz.latitude && biz.longitude)
          
          return NextResponse.json({
            response: detailFactsBlock,
            intent: 'unknown',
            needsLocation: false,
            showAtlasCta: hasCoords,
            businessCarousel: [], // Always empty in detail mode
            eventCards: [],
            mapPins: hasCoords ? [{
              id: biz.id,
              name: biz.business_name,
              latitude: biz.latitude,
              longitude: biz.longitude,
              category: biz.display_category || 'Business',
              tier: 'detail'
            }] : [],
            sources: [],
            quickReplies: [],
            metadata: {
              mode: 'detail',
              matchedBy: currentBusinessSlug ? 'slug' : 'id',
              currentBusinessSlug,
              currentBusinessId: biz.id
            }
          })
        } else {
          // FAIL CLOSED: No business found, don't hallucinate
          console.log(`‚ö†Ô∏è [DETAIL MODE] No business found for ID=${currentBusinessId} or slug=${currentBusinessSlug}`)
          // Continue to normal flow (will use AI response)
        }
      } catch (error) {
        console.error('[DETAIL MODE] Error fetching business details:', error)
        // Continue to normal flow on error
      }
    }
    
    if (!showAtlasCta && finalResponse) {
      // Remove map-related phrases (be aggressive - catch generic phrasing)
      const mapPhrases = [
        /Want to explore.*?Qwikker Atlas.*?üëá/gi,
        /Want to check out.*?Qwikker Atlas.*?üëá/gi,
        /Curious where.*?Qwikker Atlas.*?üëá/gi,
        /Jump into Qwikker Atlas.*?üëá/gi,
        /explore.*?on Qwikker Atlas.*?üëá/gi,
        /check out.*?on Qwikker Atlas.*?üëá/gi,
        /see.*?on Qwikker Atlas.*?üëá/gi,
        /view.*?on Qwikker Atlas.*?üëá/gi,
        /Just tap below.*?üëá/gi,
        /Tap below.*?üëá/gi,
        /Show me on Qwikker Atlas/gi,
        // Generic map phrasing (when model doesn't use "Atlas" keyword)
        /The map below helps you compare\.?/gi,
        /Want to see how these are spaced out\?/gi,
        /the map view makes it easy/gi,
        /map.*helps you compare/gi,
        /spaced out.*map/gi
      ]
      
      mapPhrases.forEach(pattern => {
        finalResponse = finalResponse.replace(pattern, '')
      })
      
      // Clean up ONLY excessive whitespace, preserve paragraph breaks
      finalResponse = finalResponse
        .replace(/  +/g, ' ') // Multiple spaces ‚Üí single space
        .replace(/\?\s+\?/g, '?') // Fix double question marks
        .replace(/\n{4,}/g, '\n\n') // Collapse 4+ newlines to 2 (preserve paragraph breaks!)
        .trim()
      
      if (process.env.NODE_ENV === 'development' && finalResponse !== result.response) {
        console.log('üîß Stripped Atlas mentions from response (showAtlasCta=false)')
      }
    }
    
    // üîß DETAIL MODE: Strip generic footer from model response
    if (isDetailMode && finalResponse) {
      const footerPatterns = [
        /If you'?d like more details about.*?I'?ll pull up.*?\./gi,
        /tell me which (?:place|one).*?I'?ll pull up.*?\./gi,
        /Let me know which.*?I can share.*?\./gi,
        /Want to know more about.*?Just ask.*?\./gi
      ]
      
      footerPatterns.forEach(pattern => {
        finalResponse = finalResponse.replace(pattern, '')
      })
      
      // Clean up trailing whitespace
      finalResponse = finalResponse.replace(/\n{3,}/g, '\n\n').trim()
    }
    
    // üéØ FINAL FORMATTING: Force business paragraphs (MUST BE LAST STEP)
    // This runs AFTER all text mutations (Atlas stripping, etc.)
    finalResponse = forceNewParagraphPerBusinessLink(finalResponse)
    
    // üö® GUARDRAIL: Catch vague responses when data exists (dev-only warning)
    if (process.env.NODE_ENV === 'development') {
      const bannedVagueness = [
        'typically open',
        'usually open',
        'check their site',
        'confirm on their site',
        'might be open',
        'probably open',
        'tends to be open',
        'generally open'
      ]
      
      for (const phrase of bannedVagueness) {
        if (finalResponse.toLowerCase().includes(phrase)) {
          console.error(`üö® [VAGUENESS DETECTED] Response contains "${phrase}" - model is hedging when data likely exists!`)
        }
      }
    }
    
    // üìû CONTEXT-AWARE FOOTER
    const businessLinkMatches = finalResponse.match(/\*\*\[[^\]]+\]\(\/user\/business\/[a-z0-9-]+\)\*\*/g) || []
    const businessLinkCount = businessLinkMatches.length
    
    // Use final (fallback-aware) selection state
    const userHasSelectedBusiness = !!(currentBusinessId || currentBusinessSlug)
    
    // Show footer ONLY when:
    // - We have 2+ businesses listed (choice mode)
    // - User hasn't selected a business yet
    // - NOT in detail mode
    if (businessLinkCount >= 2 && !userHasSelectedBusiness && !isDetailMode) {
      finalResponse += `\n\nIf you'd like more details about one of these, tell me which place and I'll pull up directions, opening hours, and contact details.`
    }
    
    // üîç DEV-ONLY: Verify paragraph spacing is preserved
    if (process.env.NODE_ENV === 'development') {
      const hasDoubleNewlines = finalResponse.includes('\n\n')
      console.log(`‚úÖ [FINAL] Paragraph spacing preserved: ${hasDoubleNewlines}, ${businessLinkCount} business links`)
      
      // Warn if 2+ businesses but no paragraph breaks (should never happen now)
      if (businessLinkCount >= 2 && !hasDoubleNewlines) {
        console.warn(`‚ö†Ô∏è  [FINAL] ${businessLinkCount} business links but NO paragraph breaks - formatter may have failed!`)
      }
    }
    
    // REMOVED: Quick replies are irrelevant and annoying - users can just type what they want
    const quickReplies: string[] = []
    
    if (process.env.NODE_ENV === 'development') {
      console.log('‚ú® Quick replies (server-generated, NOT from model):', quickReplies)
    }

    // Categorize the message for analytics
    const messageCategory = await categorizeUserMessage(message)
    console.log(`üìä Message category: ${messageCategory.category} (confidence: ${messageCategory.confidence})`)

    console.log('üéØ API RESPONSE:', {
      intent,
      needsLocation,
      showAtlasCta,
      hasBusinessResults: result.hasBusinessResults,
      businessCarouselCount: result.businessCarousel?.length || 0,
      eventCardsCount: result.eventCards?.length || 0
    })

    return NextResponse.json({
      response: finalResponse,
      intent,
      needsLocation,
      showAtlasCta,
      sources: result.sources || [],
      quickReplies,
      hasBusinessResults: result.hasBusinessResults,
      businessCarousel: result.businessCarousel,
      mapPins: result.mapPins, // ‚úÖ ATLAS: All businesses for map (paid + unclaimed)
      queryCategories: result.queryCategories || [], // ‚úÖ ATLAS: For filtering businesses by query
      queryKeywords: result.queryKeywords || [], // ‚úÖ ATLAS: For filtering businesses by query
      walletActions: result.walletActions,
      eventCards: result.eventCards,
      googleReviewSnippets: result.googleReviewSnippets,
      metadata: {
        city,
        userName,
        category: messageCategory.category,
        sourceCount: result.sources?.length || 0,
        modelUsed: result.modelUsed,
        complexity: result.classification?.complexity,
        intent
      }
    })

  } catch (error) {
    console.error('‚ùå AI Chat API error:', error)
    
    // Get city for personalized fallback message
    const fallbackCity = await getFranchiseCityFromRequest() || 'this city'
    const cityDisplayName = fallbackCity.charAt(0).toUpperCase() + fallbackCity.slice(1)
    
    return NextResponse.json({
      response: `I'm still getting to know ${cityDisplayName}. As local businesses verify details, I'll be able to recommend specific dishes, offers and hidden spots. For now, explore what's already live in the Discover section and your pass will update automatically.`,
      intent: 'unknown',
      needsLocation: false,
      showAtlasCta: false,
      sources: [],
      quickReplies: [], // REMOVED: Let users type what they want
      error: 'Internal server error'
    }, { status: 500 })
  }
}

// Handle preflight requests for CORS
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  })
}
